/**
 * Copyright © 2015 Smartac Inc. All rights reserved.
 * Created by Simon on 2015/11/5.
 */

var fs = require('fs');
var sprintf = require('./sprintf');
var sc = require('./scCommon');
var Promise = sc.Promise;
var path = require('path');
var colors = require('colors');
var stream = require('stream');
var util = require('util');
ELevel = {
    None: 0,
    Error: 1,
    Warn: 2,
    Info: 3,
    Debug: 4,
    Trace: 5
};
var g_console = {};
g_console.error = console.error;
g_console.warn = console.warn;
g_console.info = console.info;
g_console.debug = console.log;
g_console.log = console.log;

/*日志协议消息头
 协议版本,消息长度,日志级别
 1byte     2byte    1byte
 */
// 日志协议处理
function LogProtocolTransform(socket, options) {
    if (!(this instanceof LogProtocolTransform))
        return new LogProtocolTransform(socket, options);
    stream.Transform.call(this, { objectMode: true });
    // 接收缓冲
    this._recvBuff = null;
    // 协议版本
    this._ver = 1;
    // 数据源
    this._source = socket;


}
// 继承流
util.inherits(LogProtocolTransform, stream.Transform);

// 数据到达,准备读取
LogProtocolTransform.prototype._transform = function (data, encoding, callback) {
    if (!Buffer.isBuffer(data)) {
        try {
            // 组合头部缓冲
            var head = new Buffer(4);
            var text = new Buffer(data.text, encoding);
            if (text.length > (65535 - 4)) {
                text = text.slice(0, 65535 - 4);
            }
            head.writeUInt8(this._ver, 0);
            head.writeUInt16LE(text.length + 4, 1);
            head.writeUInt8(data.level, 3);
            // 写入,尽量一次写入一整条
            //this.push(Buffer.concat([head,text]));
            this.push(head);
            this.push(text);
            //g_console.log("sent:"+text);
            callback();
            //   g_console.debug("length=%d,level=%d,text=%s",text.length+4,data.level,text.toString());
        }
        catch (e) {
            g_console.error("write socket log crash!err=%s, ver=%s, level=%s", e, this._ver, data.level);
        }
    }
    else {
        callback();
        var chunk = data;
        if (!chunk) return;
        // 追加数据到缓冲
        if (this._recvBuff && this._recvBuff.length > 0) {
            this._recvBuff = Buffer.concat([this._recvBuff, chunk]);
        }
        else {
            this._recvBuff = chunk;
        }
        // 处理缓冲
        while (this._recvBuff.length > 10) {
            var ver = this._recvBuff.readUInt8(0);
            var length = this._recvBuff.readUInt16LE(1);
            var level = this._recvBuff.readUInt8(3);
            if (ver == this._ver && level > 0 && level <= 5) {
                if (length <= this._recvBuff.length) {
                    var text = this._recvBuff.toString('utf8', 4, length);
                    // 减小缓冲
                    this._recvBuff = this._recvBuff.slice(length, this._recvBuff.length);
                    if (text) {
                        // TODO: test
                        //g_console.log('recv:'+text.toString());
                        this.emit('log', { level: level, text: text.toString() });
                    }
                    else {
                        g_console.error("read recv buff fail!!");
                    }
                }
                else {
                    //数据不足,等待下轮
                    break;
                }
            }
            else {
                // 日志版本或级别不对
                //this._source.end();
                g_console.error("log socket data invalid!,disconnect! ver=%s, level=%s", ver, level);
                this.emit('error', new Error("log protocol invalid!"));
                break;
            }
        }
    }
}
//LogProtocolTransform.prototype._write=function(chunk, encoding, callback)
{

}


/**
 * 日志类，支持5个级别:Error,Warning,Information,Debug,Trace,None为不输出日志
 */
var Log = module.exports = function () {
    this._level = ELevel.Info;
    this._consoleLog = true;
    //含有替换符的全路径
    this._fileLog = null;
    this._fileObj = null;
    //当前日志的日期
    this._day = null;
}

Log.prototype.initSocket = function (isServer, port, autoExit) {
    var net = require('net');
    var self = this;
    if (!autoExit) autoExit = false;
    return new Promise(function (resolve, reject) {
        if (isServer) {
            // 创建服务器端
            var server = net.createServer(function (clientSocket) {// 连接已经建立
                self.debug("worker process log socket connected!");
                var logStream = new LogProtocolTransform();
                logStream.on('log', function (log) {
                    self._output(log.level, log.text);
                })
                clientSocket.pipe(logStream);

                clientSocket.on('error', function (err) {
                    self.debug("worker process log socket error!err=%s", err);
                });
                clientSocket.on('close', function () {
                    self.debug("worker process log socket close!");
                    clientSocket.end();
                    clientSocket.destroy();
                })
                logStream.once('error', function () {
                    self.debug("master log socket process error!disconnect!");
                    clientSocket.end();
                });
            });
            server.listen(0, function () {
                self.debug('master log socket server started! host=%s, port=%s', server.address().address, server.address().port);  //kay 2016.11.25 add log
                resolve(server.address().port);
            });
            server.on('error', function (err) {
                self.error('master log socket server error, err=%s', err);  //kay 2016.11.25 add log
                reject(err);
            });
        }
        else {
            self._logStream = new LogProtocolTransform();
            // 创建客户端
            self.debug('worker %d# ready to connect master log socket server, port=%s', sc.workIndex, port);
            self._clientSocket = net.connect({ port: port }, function () {
                // Socket已经连接
                self._logStream.pipe(self._clientSocket);
                resolve();
                self.debug("worker %d# log socket connected!", sc.workIndex);
            });
            self._logStream.on('error', function () {
                self.debug("worker process log socket process error!disconnect!");
                self._clientSocket.end();
            })
            self._clientSocket.on('end', function () {
                // 如果父进程连接断开,则应该是主进程已经停止,自动结束子进程
                console.warn('master process log socket disconnect!');
                if (autoExit) {
                    process.exit(120);
                }
                else {
                    // 自动重连,1秒延迟
                    setTimeout(function () {
                        self.initSocket(isServer, port, autoExit);
                    }, 1000);
                }
            });
            self._clientSocket.on('error', function (err) {
                // 发生错误
                console.warn('log socket error!err=%s', err);
                sc.assert(false, "worker log socket error");
                if (autoExit) {
                    process.exit(121);
                }
            })

        }
    });
}

/**
 * 设定日志级别
 */
Log.prototype.setLevel = function (level) {
    if (typeof (level) == "number") {
        if (level >= 0 && level <= 5) {
            this._level = level;
        } else {
            console.error("Log.setLevel Error!level invalid!level=%d", level);
        }
    } else if (typeof (level) == "string") {
        switch (level) {
            case "error":
                this.setLevel(ELevel.Error);
                break;
            case "warn":
                this.setLevel(ELevel.Warn);
                break;
            case "info":
                this.setLevel(ELevel.Info);
                break;
            case "debug":
                this.setLevel(ELevel.Debug);
                break;
            case "trace":
                this.setLevel(ELevel.Trace);
                break;
            case "none":
                this.setLevel(ELevel.None);
                break;
            default:
                console.error("Log.setLevel Error!unknow level '%s'!", level);
                break;
        }
    }
    else {
        console.error("Log.setLevel Error!unknow level type!");
    }
}

/**
 * 打开文件日志
 */
Log.prototype.enableFileLog = function (file) {
    this._fileLog = file;
}

Log.prototype._openLogFile = function (file) {
    if (this._fileObj) {
        try {
            // 日志文件已经存在,关闭
            fs.closeSync(this._fileObj);
            this._fileObj = null;
            this.realFilePath = "";
        }
        catch (e) {
            // 关闭文件过程出错
            g_console.warn("close log file error! %s", e);
        }
    }

    try {
        //日志文件的文件目录
        var dirPath = path.dirname(file);
        //判断文件路径是否存在,自动创建路径
        if (!fs.existsSync(dirPath)) sc.mkdirsSync(dirPath);
        // 打开日志文件
        this._fileObj = fs.openSync(file, 'a');
        if (this._fileObj) {
            // 记录真实文件位置
            this.realFilePath = file;
            return true;
        }
    }
    catch (e) {
        g_console.error("open log file '%s' fail!error=%s", file, e);
    }
    return false;
}
/**
 * 更新日志文件输出目标
 */
Log.prototype._updateLogFile = function () {
    if (this._fileLog) {
        var day = new Date().format('dd');
        // 日志对象没准备好,准备日志对象
        if (!this._fileObj) {
            var newFilePath = filePathFormat(this._fileLog);
            if (this._openLogFile(newFilePath)) {
                this._day = day;
            }
        } else if (this._day != day) {
            this._day = day;
            // 日期不一致,重新格式化日志文件
            var newFilePath = filePathFormat(this._fileLog);
            if (this.realFilePath != newFilePath) {
                this._openLogFile(newFilePath);
            }
        }
    }
}

// 打开控制台日志
Log.prototype.enableConsoleLog = function (enable) {
    this._consoleLog = enable;
}

/**
 * 转换日志级别为字母
 */
function convertLogLevelToString(level) {
    switch (level) {
        case 1:
            return "E";
        case 2:
            return "W";
        case 3:
            return "I";
        case 4:
            return "D";
        case 5:
            return "T";
        default:
            return "N"
    }
}

/**
 * 格式化日志
 * [D] 18:57:34.845(00007FC0B229E7E0):MQProcessor::Start
 */
Log.prototype._format = function (level, args) {
    var g_pid = sprintf("(%016X)", process.pid);
    var now = new Date();
    var msg = "[" + convertLogLevelToString(level) + "] " + now.format("hh:mm:ss.S") + g_pid + ":";
    msg += sc.formatArgs(args);
    return msg;
}

/**
 * 输出日志
 */
Log.prototype._output = function (level, msg) {
    // 开始输出
    if (!this._logStream) {
        // 直接输出
        // 输出控制台日志
        if (this._consoleLog) {
            switch (level) {
                // 直接使用数字能加快一点速度?
                case 1:// 红色
                    // Simon changed:所有日志使用stdout输出,避免双通道上下文错位问题
                    // g_console.error(msg.red);
                    g_console.log(msg.red);
                    break;
                case 2:// 黄色
                    // g_console.warn(msg.yellow);
                    g_console.log(msg.yellow);
                    break;
                case 3:// 绿色
                    // g_console.info(msg.green);
                    g_console.log(msg.green);
                    break;
                case 4:// 白色
                    //g_console.debug(msg.white);
                    g_console.log(msg.white);
                    break;
                case 5:// 灰色
                    g_console.log(msg.gray);
                    break;
                default:
                    break;
            }
        }
        if (this._fileLog) {
            this._updateLogFile();
            //获得句柄
            var fd = this._fileObj;
            if (fd) {
                try {
                    fs.writeSync(fd, msg, 0, 'utf-8');
                    fs.writeSync(fd, "\r\n", 0, 'utf-8');
                }
                catch (e) {
                    g_console.error("write log file fail!err=%s", e);
                }
            }
        }
    }
    else {
        // 输出重定向到主进程
        //process.send(msg);
        this._logStream.write({ level: level, text: msg });
    }
}
// 输出接口
Log.prototype.error = function () {
    if (this._level < ELevel.Error || arguments.length == 0) return;
    // 格式化日志
    var msg = this._format(ELevel.Error, Array.prototype.slice.call(arguments));
    this._output(ELevel.Error, msg);
}
Log.prototype.warn = function () {
    if (this._level < ELevel.Warn || arguments.length == 0) return;
    // 格式化日志
    var msg = this._format(ELevel.Warn, Array.prototype.slice.call(arguments));
    this._output(ELevel.Warn, msg);
}
Log.prototype.info = function () {
    if (this._level < ELevel.Info || arguments.length == 0) return;
    // 格式化日志
    var msg = this._format(ELevel.Info, Array.prototype.slice.call(arguments));
    this._output(ELevel.Info, msg);
}
Log.prototype.debug = function () {
    if (this._level < ELevel.Debug || arguments.length == 0) return;
    // 格式化日志
    var msg = this._format(ELevel.Debug, Array.prototype.slice.call(arguments));
    this._output(ELevel.Debug, msg);
}
Log.prototype.trace = function () {
    if (this._level < ELevel.Trace || arguments.length == 0) return;
    // 格式化日志
    var msg = this._format(ELevel.Trace, Array.prototype.slice.call(arguments));
    this._output(ELevel.Trace, msg);
}
Log.prototype.log = Log.prototype.trace;
module.exports = Log;

/**
 * FileNumber匹配
 * @param str
 * @param n 文件编号
 */
function fileNumberMatch(str, n) {
    if (str == '$(FileNumber)' || str == '$(FileNumber1)') {
        return sprintf('%d', n);
    } else if (str == '$(FileNumber2)') {
        //是00
        return sprintf('%02d', n);
    } else if (str == '$(FileNumber3)') {
        return sprintf('%03d', n);
    } else if (str == '$(FileNumber4)') {
        return sprintf('%04d', n);
    }
}

/**
 * 文件路径替换
 * @param filePath 文件路径
 */
function filePathFormat(filePath) {
    var n = 0;
    //除了FileNumber，别的都替换
    var filePath = filePath.replace(/(\$\([^$()]*\))/g, function (str) {
        return sc.formatString(str);
    })
    var file = filePath.replace(/(\$\([^$()]*\))/g, function (str) {
        return fileNumberMatch(str, n);
    });
    //判断是否有文件编号
    if (filePath.indexOf('$(FileNumber') > -1) {
        //当文件存在时，则文件编号+1，等到不存在时 返回。
        while (fs.existsSync(file)) {
            n++;
            file = filePath.replace(/(\$\([^$()]*\))/g, function (str) {
                return fileNumberMatch(str, n);
            });
        }
    }
    return path.normalize(file);
}