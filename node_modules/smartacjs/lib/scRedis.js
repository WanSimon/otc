/**
 * Copyright © 2015 Smartac Inc. All rights reserved.
 * Created by Stephen on 2015/11/04.
 */

var Redis = require('ioredis');
var domain = require('domain');
var sc = require('./scCommon');
var Promise = sc.Promise;

Redis.Promise.onPossiblyUnhandledRejection(function (error) {
    // you can log the error here.
    // error.command.name is the command name, here is 'set'
    // error.command.args is the command arguments, here is ['foo']
    console.error("redis error:cmd=%s",JSON.stringify(error));
});
////////---------------连接对象
function RedisConnection(url, name) {
    if (!!!name) name="redis";
    this.name = name;
    this.log = sc.createNamedLog(undefined, this.name);
    // 当前URL
    this._url = url;
    //this._urls = url.split(";");
    //this._urlIndex = 0;
    // 当前是否运行中
    this._isRuning = false;
    // 连接对象
    this._redisconn = null;
    // 系统通知
    this._dom = domain.create();

    var self = this;
    this._dom.on('error', function (err) {
        self.log.error("domain error:%s", err);
        self._reconnect();
    });
    //this._dom.on('connect', function (err) {
    //    self.log.error("domain 'connect':%s", err);
    //});
    //this._dom.on('ready', makeFunc (this,function (err) {
    //    self.log.error("domain ready:%s", err);
    //}));
    //this._dom.on('close', makeFunc (this,function (err) {
    //    self.log.error("domain close:%s", err);
    //}));
    //this._dom.on('reconnecting', makeFunc (this,function (err) {
    //    self.log.error("domain reconnecting:%s", err);
    //}));
    //this._dom.on('end', makeFunc (this,function (err) {
    //    self.log.error("domain end:%s", err);
    //}));
    //this._dom.on('authError', makeFunc (this,function (err) {
    //    self.log.error("domain authError:%s", err);
    //}));

}

RedisConnection.prototype._connect = function () {
    var self = this;
    return this._dom.run(function () {

        self._redisconn = new Redis(self._url, { lazyConnect: true,showFriendlyErrorStack: true });
        self._redisconn.on('ready', function () {
            self.log.info("redis ready");
        });
        self._redisconn.on('error',function () {
            self.log.error("redis error");
        });
        self._redisconn.on('connect', function () {
            self.log.info("redis connect");
        });
        self._redisconn.on('close',function () {
            self.log.info("redis close");
        });
        self._redisconn.on('reconnecting',function () {
            self.log.log("redis reconnecting");
        });
        self._redisconn.on('end', function () {
            self.log.info("redis end");
        });
        self._redisconn.on('authError', function(){
            self.log.error("redis authError")});
        self._redisconn.on('rejection',function(){
            self.log.error("redis rejection");
        });
        self._redisconn.connect();
    });
}
// 启动
RedisConnection.prototype.start = function () {
    this._isRuning = true;
    if (this._redisconn == null) {
        //this.url=this._urls[this._urlIndex];
        return this._connect();
    }
    else {
        return new Promise(function (resolve, reject) {
            reject("connection started!");
        });
    }
}
// 停止
RedisConnection.prototype.stop = function () {
    if (this._isRuning && this._redisconn != null) {
        this._close();
    }
    this._isRuning = false;
}

// 关闭
RedisConnection.prototype._close = function () {

    if (this._redisconn != null) {
        this._redisconn.disconnect()
    }
    this._redisconn = null;
}
//// 重新连接
//Connection.prototype._reconnect=function(){
//    this._close();
//    this._connect();
//}
// 是否运行中
RedisConnection.prototype.isRuning = function () {
    return this._isRuning;
}
// 是否已连接
RedisConnection.prototype.isConnected = function () {
    return this._isRuning && this._redisconn != null && this._redisconn.status === 'ready';
}

RedisConnection.prototype.set = function (key, val,time) {
    if (!this.isConnected()) {
        this.log.error('connection closed!');
        return false;
    }
    if(time)
    {
        return this.setex(key,val,time);
    }
    this._redisconn.set(key, val);
    return true;
}

RedisConnection.prototype.del = function (key) {
    if (!this.isConnected()) {
        this.log.error('connection closed!');
        return false;
    }
    this._redisconn.del(key);
    return true;
}

/**
 * 设置key value
 * @param key
 * @param val
 * @param time 过期时间(秒)
 * @returns {*}
 */
RedisConnection.prototype.setex = function (key, val, time) {
    if (!this.isConnected()) {
        this.log.error('connection closed!');
        return false;
    }
    this._redisconn.setex(key, time, val);
    return true;
}

RedisConnection.prototype.get = function (key) {
    if (!this.isConnected())//._redisconn == null)
        return new Promise(function (resolve, reject) {
            reject("connection closed!");
        });
    else
        return this._redisconn.get(key);
}

RedisConnection.prototype.findkeys = function (key) {
    if (!this.isConnected())
        return new Promise(function (resolve, reject) {
            reject("connection closed!");
        });
    else{
        var stream = this._redisconn.scanStream({
            match: key,
            count: 1000
        });

        var keys = [];
        stream.on('data', function (resultKeys) {
            for (var i = 0; i < resultKeys.length; i++) {
                //console.log("---找到keys:"+resultKeys[i]);
                keys.push(resultKeys[i]);
            }

        });
        return new Promise(function(resolve, reject){
            stream.on('end', function () {
                //console.log('-------------find the keys: '+ keys);
                resolve(keys);
            });
        });
    }
}

RedisConnection.prototype.mset = function (kvObj) {
    if (!this.isConnected()) {
        this.log.error('connection closed!');
        return false;
    }
    this._redisconn.mset(kvObj);
    return true;
}
// 获取redis连接
RedisConnection.prototype.conn=function()
{
    return this._redisconn;
}
RedisConnection.prototype.incr = function (key) {
    var　self=this;
    return new Promise(function(resolve, reject){
        if (!self.isConnected()) {
            self.log.error('connection closed!');
            reject(new Error('connection closed!'));
        }
        self._redisconn.incr(key).then(function(data){
            resolve(data);
        }).catch(function(e){
            reject(e);
        });
    });
}


exports.createRedisConnect = function (url, name) {
    return new RedisConnection(url, name);
}
