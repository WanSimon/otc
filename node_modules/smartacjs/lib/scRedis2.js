/**
 * Redis 公共类 V2
 * Created by Simon on 2016/7/20.
 */
var Redis = require('ioredis');
var sc = require('./scCommon');
var Promise = sc.Promise;

function RedisConnection(url,name)
{
    if (!!!name) name="redis2";
    this.name = name;
    this.log = sc.createNamedLog(this.name);
    // 当前URL
    this._urls = url.split(";");
    // 默认超时时间
    this._timeout=30;
    this._reconnect();
}

// // 获取就绪redis连接
// RedisConnection.prototype.getConnection=function(timeout)
// {
//     var self=this;
//     if (!timeout)timeout=self._timeout;
//     return new Promise(function (resolve, reject) {
//         self.waitReady(timeout).then(function() {
//             resolve(self.conn());
//         }).catch(function(err){
//             reject(err);
//         });
//     });
//
// };
// 获取下一个连接串
RedisConnection.prototype._nextUrl=function()
{
    if (this._urlIndex===undefined)
    {
        this._urlIndex = 0;
        this._url = this._urls[this._urlIndex];
    }
    else
    {
        if(this._urlIndex<this._urls.length) this._urlIndex++;
        else this._urlIndex=0;
        this._url = this._urls[this._urlIndex];
    }
}
// 重新连接
RedisConnection.prototype._reconnect=function()
{
    //TODO: 将这个方法使用Cluster改写
    if (this.conn)
    {
        this.conn.end();
        this.conn=null;
    }
    this._nextUrl();
    var self=this;
    this.conn=new Redis(this._url,
        {
        //lazyConnect: true,
        showFriendlyErrorStack: true ,
        retryStrategy: function (times)
            {

                if (times>100 && false)
                {
                    self.log.info("reconnect times retry count too much:%d,stop!",times);
                    return null;
                }
                else
                {
                    self.log.info("reconnect times:%d",times);
                }
                return Math.min(times * 200, 2000);
            }
        });
    this.conn.on('connect',function(){//emits when a connection is established to the Redis server.
        self.log.info("connected!");
    });
    this.conn.on('ready',function(e){//If enableReadyCheck is true, client will emit ready when the server reports that it is ready to receive commands (e.g. finish loading data from disk).
                                        // Otherwise, ready will be emitted immediately right after the connect event.
        self.log.info("ready!");

    });
    this.conn.on('error',function(e){//emits when an error occurs while connecting.
        self.log.error("error!err=%s",e);
    });
    this.conn.on('close',function(){//emits when an established Redis server connection has closed.
        self.log.error("close!");
    });
    this.conn.on('reconnecting',function(){//emits after close when a reconnection will be made. The argument of the event is the time (in ms) before reconnecting.
        self.log.error("reconnecting...");
    });
    this.conn.on('end',function(){//emits after close when no more reconnections will be made.
        self.log.error("stop and end!");
        self._reconnect();
    });
    this.conn.on('select',function(number){//emits when the database changed. The argument is the new db number.
        self.log.error("select db %d!",number);
    });

};
// 等待连接就绪
RedisConnection.prototype.waitReady=function(timeout)
{
    if (!timeout) timeout=this._timeout;
    var self=this;
    return new Promise(function (resolve, reject) {
        if (self.conn && self.conn.status=='ready') resolve(true);
        else
        {
            var outOfTime=new Date()+timeout*1000;
            var interval=setInterval(function(){
                if (self.conn && self.conn.status=='ready')
                {
                    clearInterval(interval);
                    resolve();
                }
                else if(outOfTime<new Date())
                {
                    clearInterval(interval);
                    reject(new Error("timout"));
                }
            },100);
        }
    });
};
RedisConnection.prototype.isConnected=function()
{
    return this.conn && this.conn.status=='ready';
}
// 导出:创建Redis连接
exports.createRedisConnection=function(url,name)
{
    return new RedisConnection(url,name);
};
